<!DOCTYPE html>
<html>
<head>
    <title>MacBook Air 15" 3D Window</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'SF Pro Display', -apple-system, sans-serif; }
        canvas { display: block; }
        
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(20, 20, 20, 0.8); padding: 20px; border-radius: 12px;
            border: 1px solid #333; backdrop-filter: blur(10px); z-index: 10;
        }

        #loading-screen {
            position: absolute; inset: 0; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #00ffcc; z-index: 100;
        }

        .progress-bar { width: 200px; height: 2px; background: #222; margin-top: 15px; }
        #progress-fill { width: 0%; height: 100%; background: #00ffcc; transition: width 0.3s; }

        #v-prev {
            position: absolute; bottom: 20px; right: 20px;
            width: 140px; border-radius: 8px; border: 1px solid #00ffcc;
            transform: scaleX(-1); opacity: 0.7;
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div id="status">Warming up M3 Neural Engine...</div>
        <div class="progress-bar"><div id="progress-fill"></div></div>
    </div>

    <div id="ui">
        <div style="font-weight: 600; font-size: 18px; margin-bottom: 5px;">Holographic Window</div>
        <div style="font-size: 12px; color: #888; margin-bottom: 15px;">Calibrated for 15" MacBook Air</div>
        <label style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px;">Screen Width (CM)</label><br>
        <input type="number" id="sw" value="33.3" step="0.1" style="background: #000; color: #00ffcc; border: 1px solid #444; padding: 5px; margin-top: 5px; width: 80px;">
    </div>

    <video id="webcam" style="display:none;" autoplay playsinline></video>
    <video id="v-prev" autoplay playsinline></video>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        // --- CONSTANTS ---
        let SCREEN_W = 33.3; 
        const LERP = 0.15; // Smoothness factor
        let rawPos = { x: 0, y: 0, z: 55 };
        let smoothPos = { x: 0, y: 0, z: 55 };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera();

        // 3D ROOM BACKGROUND
        const roomGroup = new THREE.Group();
        const boxSize = 100;
        const roomGeo = new THREE.BoxGeometry(boxSize, boxSize, boxSize * 2);
        const roomMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, side: THREE.BackSide });
        const roomMesh = new THREE.Mesh(roomGeo, roomMat);
        roomMesh.position.z = -boxSize;
        roomGroup.add(roomMesh);

        // Cyber Grid
        const grid = new THREE.GridHelper(boxSize * 2, 40, 0x00ffcc, 0x111111);
        grid.rotation.x = Math.PI / 2;
        grid.position.z = -boxSize;
        roomGroup.add(grid);
        scene.add(roomGroup);

        // Lighting
        const light1 = new THREE.PointLight(0x00ffcc, 100);
        light1.position.set(10, 10, -10);
        scene.add(light1);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        // Load model.glb
        let model;
        const loader = new GLTFLoader();
        loader.load('model.glb', (gltf) => {
            model = gltf.scene;
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const scale = 18 / Math.max(size.x, size.y, size.z);
            model.scale.set(scale, scale, scale);
            model.position.z = -20;
            scene.add(model);
            document.getElementById('loading-screen').style.display = 'none';
        }, (xhr) => {
            const p = (xhr.loaded / xhr.total) * 100;
            document.getElementById('progress-fill').style.width = p + '%';
        });

        // --- TRACKING LOGIC ---
        const video = document.getElementById("webcam");
        const videoPrev = document.getElementById("v-prev");
        let faceLandmarker;

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task` },
                runningMode: "VIDEO"
            });
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
            video.srcObject = videoPrev.srcObject = stream;
            video.onloadeddata = () => { predict(); };
        }

        function predict() {
            const results = faceLandmarker.detectForVideo(video, performance.now());
            if (results.faceLandmarks?.[0]) {
                const face = results.faceLandmarks[0];
                SCREEN_W = parseFloat(document.getElementById('sw').value);
                const screenH = SCREEN_W * (window.innerHeight / window.innerWidth);

                // Landmark 1 is the nose tip
                rawPos.x = (face[1].x - 0.5) * -SCREEN_W;
                rawPos.y = (face[1].y - 0.5) * -screenH;

                // Depth estimation calibrated for MacBook Camera FOV
                const eyeDist = Math.hypot(face[33].x - face[263].x, face[33].y - face[263].y);
                rawPos.z = 18 / (eyeDist + 0.01); 
            }
            requestAnimationFrame(predict);
        }

        function animate() {
            // LERP Smoothing
            smoothPos.x += (rawPos.x - smoothPos.x) * LERP;
            smoothPos.y += (rawPos.y - smoothPos.y) * LERP;
            smoothPos.z += (rawPos.z - smoothPos.z) * LERP;

            // Off-axis Projection Math
            const screenH = SCREEN_W * (window.innerHeight / window.innerWidth);
            const n = smoothPos.z;
            const f = 2000;
            const l = -SCREEN_W / 2 - smoothPos.x;
            const r =  SCREEN_W / 2 - smoothPos.x;
            const b = -screenH / 2 - smoothPos.y;
            const t =  screenH / 2 - smoothPos.y;

            camera.projectionMatrix.makePerspective(l, r, t, b, n, f);
            camera.position.set(smoothPos.x, smoothPos.y, smoothPos.z);
            camera.lookAt(smoothPos.x, smoothPos.y, 0);

            if (model) model.rotation.y += 0.005;
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        initAI();
        animate();
        window.addEventListener('resize', () => renderer.setSize(window.innerWidth, window.innerHeight));
    </script>
</body>
</html>
