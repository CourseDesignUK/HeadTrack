<!DOCTYPE html>
<html>
<head>
    <title>3D Pro-Window & Calibration</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        canvas { display: block; }
        
        /* UI Panels */
        .panel { position: absolute; color: white; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; pointer-events: auto; border: 1px solid #444; }
        #controls { top: 20px; left: 20px; width: 220px; }
        #calibration-overlay { 
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: rgba(0,255,200,0.1); display: none; z-index: 100;
            justify-content: center; align-items: center; cursor: crosshair;
        }
        
        /* Calibration Dots */
        .corner { position: absolute; width: 40px; height: 40px; border: 3px solid #00ffcc; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; background: black; }
        #tl { top: 10px; left: 10px; }
        #tr { top: 10px; right: 10px; }
        #bl { bottom: 10px; left: 10px; }
        #br { bottom: 10px; right: 10px; }

        button { background: #00ffcc; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-weight: bold; width: 100%; margin-top: 10px; }
        #video-preview { position: absolute; bottom: 20px; right: 20px; width: 120px; border-radius: 8px; transform: scaleX(-1); border: 1px solid #00ffcc; }
    </style>
</head>
<body>

    <div id="calibration-overlay">
        <div style="color: #00ffcc; font-size: 24px; text-align: center;">CALIBRATION MODE<br><span style="font-size: 14px; color: white;">Measure your screen width in CM and enter it below</span></div>
        <div id="tl" class="corner">TL</div><div id="tr" class="corner">TR</div>
        <div id="bl" class="corner">BL</div><div id="br" class="corner">BR</div>
    </div>

    <div id="controls" class="panel">
        <div style="font-weight: bold; color: #00ffcc;">Display Settings</div>
        <label style="font-size: 12px;">Screen Width (cm):</label>
        <input type="number" id="screenWidthInput" value="35" style="width: 60px; background: #222; color: white; border: 1px solid #444;">
        <button onclick="toggleCalibration()">Start Calibration</button>
        <div id="status" style="font-size: 11px; margin-top: 10px; color: #aaa;">Status: AI Initializing...</div>
    </div>

    <video id="webcam" style="display:none;" autoplay playsinline></video>
    <video id="video-preview" autoplay playsinline></video>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        // State Variables
        let screenW = 35; 
        let rawPos = { x: 0, y: 0, z: 60 };
        let smoothPos = { x: 0, y: 0, z: 60 };
        const lerp = 0.12;

        // --- THREE.JS SCENE ---
        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera();

        // 3D Background: The "Deep" Room
        const roomGroup = new THREE.Group();
        const roomGeom = new THREE.BoxGeometry(100, 100, 200);
        const roomMat = new THREE.MeshStandardMaterial({ 
            color: 0x111111, side: THREE.BackSide, 
            roughness: 0.8, metalness: 0.2 
        });
        const room = new THREE.Mesh(roomGeom, roomMat);
        room.position.z = -100; // Room goes deep into screen
        roomGroup.add(room);

        // Add Room Accents (The Grids)
        const gridHelper = new THREE.GridHelper(200, 20, 0x00ffcc, 0x222222);
        gridHelper.rotation.x = Math.PI / 2;
        gridHelper.position.z = -100;
        roomGroup.add(gridHelper);
        scene.add(roomGroup);

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const pointLight = new THREE.PointLight(0x00ffcc, 1000);
        pointLight.position.set(0, 20, -10);
        scene.add(pointLight);

        // Load model.glb
        let model;
        const loader = new GLTFLoader();
        loader.load('model.glb', (gltf) => {
            model = gltf.scene;
            model.position.z = -20;
            scene.add(model);
            document.getElementById('status').innerText = "Status: Running";
        });

        // --- AI & CAMERA LOGIC ---
        const video = document.getElementById("webcam");
        const videoPrev = document.getElementById("video-preview");
        let faceLandmarker;

        async function init() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task` },
                runningMode: "VIDEO", numFaces: 1
            });
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = videoPrev.srcObject = stream;
            video.onloadeddata = () => detect();
        }

        function detect() {
            const result = faceLandmarker.detectForVideo(video, performance.now());
            if (result.faceLandmarks?.[0]) {
                const face = result.faceLandmarks[0];
                const nose = face[1];
                screenW = parseFloat(document.getElementById('screenWidthInput').value);
                const screenH = screenW * (window.innerHeight / window.innerWidth);

                rawPos.x = (nose.x - 0.5) * -screenW;
                rawPos.y = (nose.y - 0.5) * -screenH;
                
                // Depth logic: more eye distance = closer head
                const eyeDist = Math.abs(face[33].x - face[263].x);
                rawPos.z = 20 / (eyeDist + 0.05); 
            }
            requestAnimationFrame(detect);
        }

        function animate() {
            // Smoothing
            smoothPos.x += (rawPos.x - smoothPos.x) * lerp;
            smoothPos.y += (rawPos.y - smoothPos.y) * lerp;
            smoothPos.z += (rawPos.z - smoothPos.z) * lerp;

            // Manual Perspective Matrix (The Window Logic)
            const n = smoothPos.z;
            const f = 2000;
            const screenH = screenW * (window.innerHeight / window.innerWidth);
            const l = -screenW / 2 - smoothPos.x;
            const r =  screenW / 2 - smoothPos.x;
            const b = -screenH / 2 - smoothPos.y;
            const t =  screenH / 2 - smoothPos.y;

            camera.projectionMatrix.makePerspective(l, r, t, b, n, f);
            camera.position.set(smoothPos.x, smoothPos.y, smoothPos.z);
            camera.lookAt(smoothPos.x, smoothPos.y, 0);

            if (model) model.rotation.y += 0.01;
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        window.toggleCalibration = () => {
            const overlay = document.getElementById('calibration-overlay');
            overlay.style.display = overlay.style.display === 'flex' ? 'none' : 'flex';
        };

        window.addEventListener('resize', () => renderer.setSize(window.innerWidth, window.innerHeight));
        init();
        animate();
    </script>
</body>
</html>
