<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Holographic Window – Hand Scale</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  margin: 0;
  overflow: hidden;
  background: black;
  font-family: -apple-system, system-ui;
  color: #00ffcc;
}
canvas { display:block; }

#ui {
  position: fixed;
  top: 20px;
  left: 20px;
  background: rgba(0,0,0,0.85);
  padding: 14px;
  border-radius: 12px;
  border: 1px solid #333;
  font-size: 12px;
}

#loading {
  position: fixed;
  inset: 0;
  background: black;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #333;
  border-top: 4px solid #00ffcc;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin { to { transform: rotate(360deg); } }

#v-prev {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 140px;
  opacity: 0.5;
  border: 1px solid #00ffcc;
  border-radius: 8px;
  transform: scaleX(-1);
}
</style>
</head>

<body>

<div id="loading"><div class="spinner"></div></div>

<div id="ui">
  <b>HAND SCALE MODE</b><br>
  Two hands apart = grow<br>
  Two hands together = shrink<br>
  <span id="debug">Waiting for hands…</span>
</div>

<video id="webcam" autoplay playsinline style="display:none"></video>
<video id="v-prev" autoplay playsinline></video>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { HandLandmarker, FilesetResolver }
  from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7";

/* ───────── THREE ───────── */

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.01);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 10, 2000);
camera.position.set(0,0,60);

/* Lighting */
scene.add(new THREE.DirectionalLight(0xffffff, 3).position.set(10,20,20));
scene.add(new THREE.AmbientLight(0xffffff, 0.6));

/* Grid */
const grid = new THREE.GridHelper(500, 50, 0x00ffcc, 0x222222);
grid.rotation.x = Math.PI/2;
grid.position.z = -120;
scene.add(grid);

/* ───────── LOAD MODEL ───────── */

let model;
let baseScale = 1;
let targetScale = 1;
let smoothScale = 1;

const loader = new GLTFLoader();
loader.load("model.glb", gltf => {
  model = gltf.scene;

  const box = new THREE.Box3().setFromObject(model);
  const size = box.getSize(new THREE.Vector3()).length();
  baseScale = 30 / size;

  model.scale.setScalar(baseScale);
  box.getCenter(model.position).multiplyScalar(-1);
  model.position.z = -60;

  scene.add(model);
  document.getElementById("loading").style.display = "none";
});

/* ───────── HAND TRACKING ───────── */

const video = document.getElementById("webcam");
let handLandmarker;
let baselineDist = null;

async function initHands() {
  const vision = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/wasm"
  );

  handLandmarker = await HandLandmarker.createFromOptions(vision, {
    baseOptions: {
      modelAssetPath:
        "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task"
    },
    runningMode: "VIDEO",
    numHands: 2
  });

  const stream = await navigator.mediaDevices.getUserMedia({ video:true });
  video.srcObject = document.getElementById("v-prev").srcObject = stream;

  video.onloadeddata = () => {
    trackHands();
    animate();
  };
}

function trackHands() {
  const res = handLandmarker.detectForVideo(video, performance.now());

  if (res.landmarks && res.landmarks.length === 2) {
    const a = res.landmarks[0][8]; // index tip
    const b = res.landmarks[1][8];

    const d = Math.hypot(a.x - b.x, a.y - b.y);

    if (!baselineDist) baselineDist = d;

    const scaleFactor = THREE.MathUtils.clamp(d / baselineDist, 0.4, 3.0);
    targetScale = baseScale * scaleFactor;

    document.getElementById("debug").innerText =
      `Scale: ${scaleFactor.toFixed(2)}×`;
  } else {
    baselineDist = null;
    document.getElementById("debug").innerText = "Show two hands";
  }

  requestAnimationFrame(trackHands);
}

/* ───────── ANIMATE ───────── */

function animate() {
  smoothScale += (targetScale - smoothScale) * 0.15;

  if (model) {
    model.scale.setScalar(smoothScale);
    model.rotation.y += 0.002;
  }

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

initHands();
addEventListener("resize", ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
