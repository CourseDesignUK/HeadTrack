<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Holographic Window – 500mm Fixed Calibration</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  margin: 0;
  overflow: hidden;
  background: black;
  font-family: -apple-system, system-ui;
  color: #00ffcc;
}
canvas { display: block; }

#ui {
  position: fixed;
  top: 20px;
  left: 20px;
  background: rgba(0,0,0,0.85);
  padding: 14px;
  border-radius: 12px;
  border: 1px solid #333;
  font-size: 12px;
}

#loading {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: black;
  z-index: 100;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #333;
  border-top: 4px solid #00ffcc;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin { to { transform: rotate(360deg); } }

#v-prev {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 140px;
  opacity: 0.5;
  border: 1px solid #00ffcc;
  border-radius: 8px;
  transform: scaleX(-1);
}
</style>
</head>

<body>

<div id="loading"><div class="spinner"></div></div>

<div id="ui">
  <b>HOLOGRAPHIC WINDOW</b><br>
  Fixed Screen: 33.3 cm<br>
  Target Depth: 500 mm<br>
  <span id="debug">Tracking…</span>
</div>

<video id="webcam" autoplay playsinline style="display:none"></video>
<video id="v-prev" autoplay playsinline></video>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { FaceLandmarker, FilesetResolver } from
  "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7";

/* ───────────────── CONFIG ───────────────── */

const SCREEN_W = 33.3;     // cm (15" MacBook Air)
const TARGET_Z = 50.0;     // cm (500 mm)
const IPD = 6.4;           // cm
const LERP = 0.12;

let raw = { x:0, y:0, z:TARGET_Z };
let smooth = { x:0, y:0, z:TARGET_Z };

/* ───────────────── THREE SETUP ───────────────── */

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.01);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.autoClear = false;
document.body.appendChild(renderer.domElement);

const camL = new THREE.PerspectiveCamera();
const camR = new THREE.PerspectiveCamera();

/* Lighting */
scene.add(new THREE.DirectionalLight(0xffffff, 3).position.set(10,20,20));
scene.add(new THREE.AmbientLight(0xffffff, 0.6));

/* Grid */
const grid = new THREE.GridHelper(500, 50, 0x00ffcc, 0x222222);
grid.rotation.x = Math.PI/2;
grid.position.z = -120;
scene.add(grid);

/* Depth layers */
[
  { z:-30, c:0x00ffaa },
  { z:-60, c:0x00ccff },
  { z:-90, c:0xff00cc }
].forEach(l=>{
  const m = new THREE.Mesh(
    new THREE.BoxGeometry(14,14,14),
    new THREE.MeshStandardMaterial({
      color:l.c, transparent:true, opacity:0.85
    })
  );
  m.position.z = l.z;
  scene.add(m);
});

/* ───────────────── TRACKING ───────────────── */

const video = document.getElementById("webcam");
let landmarker;

async function initTracking() {
  const vision = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.7/wasm"
  );

  landmarker = await FaceLandmarker.createFromOptions(vision, {
    baseOptions: {
      modelAssetPath:
        "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"
    },
    runningMode: "VIDEO"
  });

  const stream = await navigator.mediaDevices.getUserMedia({ video:true });
  video.srcObject = document.getElementById("v-prev").srcObject = stream;

  video.onloadeddata = () => {
    document.getElementById("loading").style.display = "none";
    track();
    animate();
  };
}

function track() {
  const r = landmarker.detectForVideo(video, performance.now());
  if (r.faceLandmarks?.[0]) {
    const lm = r.faceLandmarks[0];
    const L = lm[33], R = lm[263];
    const cx = (L.x + R.x)/2;
    const cy = (L.y + R.y)/2;

    const aspect = innerHeight/innerWidth;
    const screenH = SCREEN_W * aspect;

    raw.x = (cx - 0.5) * -SCREEN_W;
    raw.y = (cy - 0.5) * -screenH;

    const eyeDist = Math.hypot(L.x - R.x, L.y - R.y);
    raw.z = THREE.MathUtils.clamp(
      TARGET_Z + (0.085 - eyeDist) * 55,
      35, 90
    );

    document.getElementById("debug").innerText =
      `Z: ${raw.z.toFixed(1)} cm`;
  }
  requestAnimationFrame(track);
}

/* ───────────────── STEREO FRUSTUM ───────────────── */

function applyEye(cam, offsetX) {
  const aspect = innerHeight/innerWidth;
  const screenH = SCREEN_W * aspect;

  const n = 10, f = 2000;
  const z = smooth.z;

  const ex = smooth.x + offsetX;

  const l = ((-SCREEN_W/2) - ex) * n / z;
  const r = (( SCREEN_W/2) - ex) * n / z;
  const b = ((-screenH/2) - smooth.y) * n / z;
  const t = (( screenH/2) - smooth.y) * n / z;

  cam.projectionMatrix.makePerspective(l,r,t,b,n,f);
  cam.position.set(ex, smooth.y, z);
  cam.quaternion.identity();
  cam.updateMatrixWorld(true);
}

/* ───────────────── ANIMATE ───────────────── */

function animate() {
  smooth.x += (raw.x - smooth.x) * LERP;
  smooth.y += (raw.y - smooth.y) * LERP;
  smooth.z += (raw.z - smooth.z) * LERP;

  renderer.clear();

  applyEye(camL, -IPD/2);
  renderer.render(scene, camL);

  renderer.clearDepth();

  applyEye(camR,  IPD/2);
  renderer.render(scene, camR);

  requestAnimationFrame(animate);
}

initTracking();
addEventListener("resize", ()=>renderer.setSize(innerWidth, innerHeight));
</script>
</body>
</html>
